@code_type lua .lua
@comment_type -- %s
@title Literate

@s Introduction

This is the main file that puts `tangle` and `weave` together into one program. It
accepts the flags `-html` and `-code` if the user would like to generate only one
or the other. By default both html and code will be generated. We also accept any
number of `.lit` files, and if none are specified use `STDIN` and `STDOUT`.

Here is the structure:

--- lit.lua
gen = arg[1]
package.path = gen .. "/?.lua;" .. package.path

require("stringutil")
require("fileutil")

require("weave")
require("tangle")

require("index")

md = require("markdown")

@{Function to identify the os}
@{Function to resolve @include statements}

@{Parse the arguments}
if #inputfiles == 0 then
    @{Use STDIN and STDOUT}
else
    @{Weave and/or tangle the input files}
end
---

@s

First we parse all the arguments that the user has passed. We create two flags 
`html` and `code` which will tell us later on what to generate. We also create
an addition flag which specifies which directory to output the html/code to.
The `index` flag tells us whether or not to create an index.  Finally, we need
an array to hold the input filenames.

--- Parse the arguments
html = false
code = false
outdir = "."
index = true

inputfiles = {}
---

@s

Next we loop through each argument and check if it is one of the possible flags:

* `-h`: Get the usage help
* `-html`: Only generate html
* `-code`: Only generate code
* `-noindex`: Don't create an index
* `--out-dir=dir`: Specify the directory to output html and/or code

If the arguments is not one of these flags, we add the argument to the `inputfiles` 
array.

--- Parse the arguments +=
for i=2,#arg do
    argument = arg[i]
    if argument == "-h" then
        print("Usage: lit [-noindex] [-html] [-code] [--out-dir=dir] [file ...]")
        os.exit()
    elseif argument == "-html" then
        html = true
    elseif argument == "-code" then
        code = true
    elseif argument == "-noindex" then
        index = false
    elseif startswith(argument, "--out-dir=") then
        outdir = string.sub(argument, 11, #argument)
    else
        inputfiles[#inputfiles + 1] = argument
    end
end
---

@s

Finally, we check if the user did not specify `-html` nor `-code`. In that case,
they should both become true.

--- Parse the arguments +=
if not html and not code then
    html = true
    code = true
end
---

@s

If no input files were passed in, we should take input from `STDIN` and spit all
output to `STDOUT`.

--- Use STDIN and STDOUT
@{Declare a few globals}
local source_dir = "."

complete_source = readall()
complete_source = resolve_includes(complete_source, source_dir)
local lines = split(complete_source, "\n")

stdin = true
if html then
    local output = weave(lines, ".", "none", index)
    write("STDOUT", output)
end

if code then
    tangle(lines)
end
---

@s

If input files were given, we should loop through each one and tangle/weave it.

--- Weave and/or tangle the input files
for num,file in pairs(inputfiles) do
    @{Declare a few globals}

    local source_dir = dirname(file)
    if source_dir == "" then
        source_dir = "."
    end

    complete_source = readall(file)
    complete_source = resolve_includes(complete_source, source_dir)
    local lines = split(complete_source, "\n")

    if html then
        local output = weave(lines, source_dir, file, index)
        local outputstream = io.open(outdir .. "/" .. name(file) .. ".html", "w")
        write(outputstream, output)
        outputstream:close()
    end
    if code then
        tangle(lines)
    end
end
---

@s
We declare a few globals here so that they will be reset every time a new file is
parsed. These globals are useful for weave.

The global variables defined here will hold the results of the first pass to get the locations of code blocks and other
useful information like the number of sections and the title.

--- Declare a few globals
title = ""
block_locations = {} -- String => (Number => Number)
block_use_locations = {} -- String => (Number => Number)
---

@s

We also define `codetype` and `codetype_ext` to hold the name and extension of the language the user is using.

--- Declare a few globals +=
codetype = ""
codetype_ext = ""
---

Finally we define an array for holding the line numbers (in the lit file) on which there was code, and an array for
holding the line numbers each section starts on.

--- Declare a few globals +=
code_lines = {} -- Number => Number
section_linenums = {} -- Number => Number
---

@s

We also need to define the `resolve_includes` function which will follow `@include`
statements and if they are including a `.lit` file it will take the contents of that
file and inline it.

This function takes in a string with the source of the lit file and gives back a 
string with all `@include` statements resolved.
also recursively follow all `@include` statements that are inside the included files
too.

--- Function to resolve @include statements
function resolve_includes(source, source_dir)
    local newSource = ""
    local lines = split(source, "\n")

    for i=1,#lines do
        local line = lines[i]

        if startswith(line, "@include") then
            local filename = basename(strip(line:sub(10)))
            local filetype = filename:match(".*%.(.*)")
            local file = source_dir .. "/" .. strip(line:sub(10))
            if not file_exists(file) then
                print("Weave error: line " .. i .. ": Included file ".. file .. " does not exist.")
                exit()
            end

            if filetype == "lit" then
                newSource = newSource .. resolve_includes(readall(file), source_dir)
            end
        end

        newSource = newSource .. line .. "\n"
    end

    return newSource
end
---

@s

Lastly, we make a function that will be useful in the future to identify
what OS we are working with. We determine this by looking at whether
the OS uses `dll`, `so`, or `dylib` as the shared library extension.

--- Function to identify the os
if package.config:sub(1, 1) == "/" then
    function os.name()
        return "Unix"
    end
elseif package.config:sub(1, 1) == "\\" then
    function os.name()
        return "Windows"
    end
end
---
