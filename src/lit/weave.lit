@codetype Julia jl
@title Weave

@s Introduction
Weave is the part of `Literate` which takes a `.lit` file and generates HTML for it to be viewed in a browser.
It creates the structure for the webpage and adds the useful links from and to sections. Weave must also transform
the prose from text to markdown. To do this, we use Julia's Markdown capabilities.

Generally, the strategy is to parse each line, and make some transformation on it to turn it into html.

The structure of the file looks like this:

--- weave.jl
include("common.jl")

@{Define the write_markdown function}
@{Define the weave function}
---

@s
This is a small function which takes some text and turns it into markdown using Julia's Markdown support.
Markdown will escape any HTML symbols, which is a good thing, but sometimes it is useful to be able to write some HTML
from Markdown, so we define a couple things that transform `\<` directly to `<` in the HTML.

--- Define the write_markdown function
function write_markdown(markdown, out)
    if markdown != ""
        html = Markdown.parse(markdown) |> Markdown.html
        # Here is where we replace \(escaped character code) to what it should be in HTML
        html = replace(html, "\\&lt;", "<")
        html = replace(html, "\\&gt;", ">")
        html = replace(html, "\\&#61;", "=")
        html = replace(html, "\\&quot;", "\"")
        html = replace(html, "&#36;", "\$")
        html = replace(html, "\\\$", "&#36;")
        write(out, "$html\n")
    end
end
---

@s

--- Define the weave function
function weave(inputstream, outputstream)
    out = outputstream

    input = readall(inputstream)
    get_locations(input)
    lines = readlines(IOBuffer(input))

    @{Setup html}
    @{Setup variables}

    for line_num = 1:length(lines)
        line = lines[line_num] |> chomp

        @{Parse the line}
    end

    @{Cleanup}
end
---

@s

In this section, we define the starting structure for the html document. We include some scripts and CSS stylesheets.

--- Setup html
start_codeblock = "<pre class=\"prettyprint\">\n"
end_codeblock = "</pre>\n"

scripts = """<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
             <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
             <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['\$','\$']]}}); </script>"""

@{Get the CSS}

base_html = """<!doctype html>
               <html>
               <head>
               <meta charset="utf-8">
               <title>$title</title> # This was defined by common.jl
               $scripts
               <style>
               $css
               </style>
               </head>
               <body>
               """

write(out, base_html)
---

@s

Getting the CSS is slightly more complex because we allow the user to define their own style sheets in the current directory.

--- Get the CSS
css = ""
files = readdir(pwd()) # All the files in the current directory
if "default.css" in files
    css = readall("$(pwd())/default.css") # Read the user's default.css
else
    css = readall("$dir/default.css") # Use the default css
end

if "colorscheme.css" in files
    css *= readall("$(pwd())/colorscheme.css") # Read the user's colorscheme.css
else
    css *= readall("$dir/colorscheme.css") # Use the default colorscheme
---

@s

We initialize some variables here before beginning to parse.

--- Setup variables
sectionnum = 0 # Which section number we are currently parsing
in_codeblock = false # Whether or not we are parsing a some code
in_prose = false # Whether or not we are parsing prose
markdown = "" # This variable holds the current markdown that needs to be transformed to html

cur_codeblock_name = "" # The name of the current codeblock begin parsed
---

@s

This is where the real stuff happens.

--- Parse the line
if line == ""
    # This was a blank line
    markdown *= "\n" # Tell markdown this was a blank line
    continue
end

if startswith(line, "@codetype") # Ignore this line
    continue
end

@{Check for code blocks beginning or ending}
@{Check for section names that need to be linked}
@{Check for a new section being created}
@{Check for the title}
---

@s

--- Check for code blocks beginning or ending
if ismatch(r"^---.+$", line)
    # A code block just began
    in_prose = false
    in_codeblock = true
    # Write the current markdown
    write_markdown(markdown, out)
    # Reset the markdown
    markdown = ""

    @{Begin codeblock}
elseif ismatch(r"^---$", line)
    # A code block just ended
    in_prose = true
    in_codeblock = false

    @{End codeblock}
end
---

@s

When a code block begins, we need to write out the name of the code block in {} and if it is a file,
write it in bold. We also wrap the title, codeblock, and any links that come afterward in a div.

--- Begin codeblock
write(out, "<div class=\"codeblock\">\n")
name = strip(line[4:end]) # The codeblock name

file = false # Whether or not this name is a file name
adding = false # Whether or not this block is a +=

if contains(name, "+=")
    name = strip(name[1:search(name, "+")[end]-1]) # Remove the += from the name
    adding = true
end

cur_codeblock_name = name
file = ismatch(r"^.+\w.\w+$", name)

definition_location = block_locations[name][1]
output = "$name <a href\"#$definition_location\">$definition_location</a>" # Add the link to the definition location
output = "${$output} $(adding ? "+" : "")â‰¡" # Add the = or +=

if file
    output = "<strong>$output</strong>" # If the name is a file, make it bold
end

write(out, "<p class=\"notp\" id=\"$name$sectionnum"><span class=\"codeblock_name\">$output</span></p>\n")
# We can now begin pretty printing the code that comes next
write(out, start_codeblock)
---

@s

When a codeblock ends, we have to write two things. We must write out any links to other places where this codeblock gets added to,
and we have to write any links to places where this code block is used. Luckily, once we get the block name, this is really simple
thanks to the `block_locations` and `block_use_locations` dictionaries.

--- End codeblock
# First start by ending the pretty printing
write(out, end_codeblock)
# This was stored when the code block began
name = cur_codeblock_name

@{Write any "see also" links}
@{Write any "used in" links}
# Close the "codeblock" div
write(out, "</div>\n")
---

@s

When writing see also links, we only want to list links where this code section has been *added* to, not where it was defined.
That means we have to exclude `block_locations[name][1]`. In addition, if the section where the codeblock was added to is the
current section, we don't want to write that out.

We also have to perform a few extra checks to make sure we get our grammar right.

--- Write any "see also" links
locations = block_locations[name]
if length(locations) > 1
    links = "" # This will hold the html for the links
    loopnum = 0
    for i = 2:length(locations)
        location = locations[i]
        if location != sectionnum
            loopnum += 1
            punc = "" # We might need a comma or 'and'
            if loopnum > 1 && loopnum < length(locations)-1
                punc = ","
            elseif loopnum == length(locations)-1 && loopnum > 1
                punc = "and"
            end
            links *= "$punc <a href=\"#$location\">$location</a>"
        end
    end
    if loopnum > 0
        write(out, "<p class=\"seealso\">See also section$(loopnum > 1 ? "s" : "") $links.</p>\n")
    end
end
---

@s

When writing the links that tell you which section this code was used in, we do something very similar to before.

--- Write any "used in" links
# Top level codeblocks such as files are never used, so we have to check here
if haskey(block_use_locations, name)
    locations = block_use_locations[name]
    output = "<p class=\"seealso\">This code is used in section$(length(locations) > 1 ? "s" : "")"
    for i in 1:length(locations)
        location = locations[i]
        punc = ""
        if i > 1 && i < length(arr)
            punc = ","
        elseif i == length(arr) && i != 1
            punc = " and"
        end
        output *= "$punc <a href=\"#$location\">$location</a>"
    end
    output *= ".</p>\n"
    write(out, output)
end
---
